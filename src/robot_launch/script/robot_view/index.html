<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Robot Control</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="connection-status-bar">
        <div id="robotStatus"></div>
        <div id="connectionStatus" class="disconnected">Connected Robot Error</div>
    </div>

    <div class="top-nav">
        <h1>机器人控制中心</h1>
        <div>
            <button class="func-btn" id="btn-show-panel">功能面板</button>
            <button class="func-btn" id="btn-show-remote">摇杆控制</button>
        </div>
    </div>

    <div class="main-content">
        <div id="map-area">
            <canvas id="map-canvas"></canvas>
            <div id="map-controls">
                <div class="control-label">地图控制</div>
                <div class="control-group">
                    <button id="reset-view">重置视图</button>
                    <button id="zoom-in">放大</button>
                    <button id="zoom-out">缩小</button>
                </div>
                <div class="control-group">
                    <button id="rotate-left">左转视图</button>
                    <button id="rotate-right">右转视图</button>
                </div>
                <div class="control-group">
                    <button id="init-pose-btn">初始位姿</button>
                    <button id="get-clicked-point">获取地图点</button>
                </div>
                <div class="toggle-group">
                    <input type="checkbox" id="show-pointcloud" checked>
                    <label for="show-pointcloud">显示点云</label>
                </div>
                <div class="toggle-group">
                    <input type="checkbox" id="show-markers" checked>
                    <label for="show-markers">显示节点</label>
                </div>
                <div class="toggle-group">
                    <input type="checkbox" id="show-robot" checked>
                    <label for="show-robot">显示机器人</label>
                </div>
            </div>

            <div id="ros-log-panel">
                <div class="log-label">机器人实时日志</div>
                <ul id="ros-log-list"></ul>
            </div>

            <div id="status-toast">连接状态：未连接</div>
            <div class="map-lock-toast" id="map-lock-toast">地图已锁定，单击获取坐标</div>
        </div>

        <div id="side-panel">
            <div class="panel-header">
                <span>功能面板</span>
                <button class="close-btn" id="close-panel">×</button>
            </div>
            <div class="panel-content">
                <div class="collapse-panel">
                    <div class="collapse-header active" data-target="state-body">机器人状态</div>
                    <div class="collapse-body show" id="state-body">
                        <div class="state-grid">
                            <div class="battery-item">
                                <label>电池/充电</label>
                                <div class="battery-bar">
                                    <div class="battery-fill" id="battery-fill" style="width: 0%"></div>
                                    <div class="charge-text" id="charge-text">None</div>
                                </div>
                                <div class="battery-percent" id="battery-percent">0%</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapse-panel">
                    <div class="collapse-header" data-target="joystick-body">摇杆控制</div>
                    <div class="collapse-body" id="joystick-body">
                        <div class="joystick-container">
                            <div class="joystick-title">拖动摇杆控制机器人</div>
                            <div class="joystick-wrapper">
                                <div class="joystick-base"></div>
                                <div class="joystick-knob" id="joystick-knob"></div>
                            </div>
                            <button class="nav-btn primary" id="btn-sensor-control"
                                style="margin-top: 15px;">开启体感控制</button>
                            <div class="joystick-hint">松开摇杆自动停止 | 拖动越远速度越快</div>
                        </div>
                    </div>
                </div>

                <div class="collapse-panel">
                    <div class="collapse-header" data-target="nav-body">导航功能</div>
                    <div class="collapse-body" id="nav-body">
                        <div class="param-row">
                            <label>选择节点</label>
                            <select id="node-select" class="node-select">
                                <option value="">请选择节点</option>
                            </select>
                            <button class="nav-btn primary" id="btn-set-goal-from-node">设置目标点</button>
                        </div>
                        <div class="nav-actions">
                            <button class="nav-btn primary" id="btn-start-nav">开始导航</button>
                            <button class="nav-btn primary" id="btn-stop-nav">停止导航</button>
                        </div>
                    </div>
                </div>

                <div class="collapse-panel">
                    <div class="collapse-header" data-target="sys-body">系统设置</div>
                    <div class="collapse-body" id="sys-body">
                        <div class="param-row">
                            <label>节点名称</label>
                            <input type="text" id="node-name" placeholder="输入节点名">
                            <button class="nav-btn primary" id="btn-add-node">插入节点</button>
                        </div>
                        <div class="sys-btn-group">
                            <button class="nav-btn primary" id="btn-del-node">删除节点</button>
                            <button class="nav-btn primary" id="btn-save-path">保存</button>
                            <button class="nav-btn primary" id="btn-connect-node">连接节点</button>
                            <button class="nav-btn primary" id="btn-del-connect">删除连接</button>
                            <button class="nav-btn primary" id="btn-modify-dir">修改方向</button>
                            <button class="nav-btn primary" id="btn-set-charge">设置充电点</button>
                            <button class="nav-btn primary" id="btn-onekey-charge">一键充电</button>
                            <button class="nav-btn primary" id="btn-end-charge">结束充电</button>
                        </div>

                        <div class="control-label" style="font-size:14px; color:#333; margin:12px 0 6px 0;">调试控制</div>
                        <div class="debug-btn-group">
                            <button class="nav-btn primary" id="btn-left-feed">左侧上料</button>
                            <button class="nav-btn primary" id="btn-right-feed">右侧上料</button>
                            <button class="nav-btn primary" id="btn-left-unload">左侧下料</button>
                            <button class="nav-btn primary" id="btn-right-unload">右侧下料</button>
                            <button class="nav-btn primary" id="btn-reflection-debug" colspan="3">开启反光贴调试</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="overlay"></div>
    </div>

    <script src="js/easeljs.min.js"></script>
    <script src="js/eventemitter2.min.js"></script>
    <script src="js/roslib.min.js"></script>
    <script src="js/ros2d.min.js"></script>
    <script src="js/ros3d.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/createjs.min.js"></script>
    <script src="js/ros_init.js"></script>
    <script>
        // 全局变量初始化
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const statusToast = document.getElementById('status-toast');
        const mapLockToast = document.getElementById('map-lock-toast');
        const rosLogList = document.getElementById('ros-log-list');
        const rosLogPanel = document.getElementById('ros-log-panel');
        const mapControls = document.getElementById('map-controls');
        const MAX_LOG_ITEMS = 50;

        // DOM元素获取
        const btnShowPanel = document.getElementById('btn-show-panel');
        const btnShowRemote = document.getElementById('btn-show-remote');
        const btnClosePanel = document.getElementById('close-panel');
        const sidePanel = document.getElementById('side-panel');
        const overlay = document.getElementById('overlay');
        const resetViewBtn = document.getElementById('reset-view');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const rotateLeftBtn = document.getElementById('rotate-left');
        const rotateRightBtn = document.getElementById('rotate-right');
        const initPoseBtn = document.getElementById('init-pose-btn');
        const getClickedPointBtn = document.getElementById('get-clicked-point');
        const showPointcloudCheckbox = document.getElementById('show-pointcloud');
        const showMarkersCheckbox = document.getElementById('show-markers');
        const showRobotCheckbox = document.getElementById('show-robot');
        const batteryFill = document.getElementById('battery-fill');
        const batteryPercent = document.getElementById('battery-percent');
        const chargeText = document.getElementById('charge-text');
        const joystickKnob = document.getElementById('joystick-knob');
        const btnStartNav = document.getElementById('btn-start-nav');
        const btnStopNav = document.getElementById('btn-stop-nav');
        const btnSetGoalFromNode = document.getElementById('btn-set-goal-from-node');
        const nodeSelect = document.getElementById('node-select');
        const btnAddNode = document.getElementById('btn-add-node');
        const btnDelNode = document.getElementById('btn-del-node');
        const btnSavePath = document.getElementById('btn-save-path');
        const btnConnectNode = document.getElementById('btn-connect-node');
        const btnDelConnect = document.getElementById('btn-del-connect');
        const btnModifyDir = document.getElementById('btn-modify-dir');
        const btnSetCharge = document.getElementById('btn-set-charge');
        const btnOnekeyCharge = document.getElementById('btn-onekey-charge');
        const btnEndCharge = document.getElementById('btn-end-charge');
        const nodeNameInput = document.getElementById('node-name');
        const btnLeftFeed = document.getElementById('btn-left-feed');
        const btnRightFeed = document.getElementById('btn-right-feed');
        const btnLeftUnload = document.getElementById('btn-left-unload');
        const btnRightUnload = document.getElementById('btn-right-unload');
        const btnReflectionDebug = document.getElementById('btn-reflection-debug');

        // 状态变量
        let isReflectionDebugActive = false;
        let mapData = null;
        let robotPose = null;
        let markerArrayData = null;
        let pointCloudData = null;
        let offscreenCanvas, offscreenCtx;
        let nodeMap = null;
        let viewState = { scale: 10.0, rotation: 0.0, translateX: 0, translateY: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let isViewDirty = true;
        let isSettingInitPose = false;
        let initPoseStartPos = null;
        let initPoseCurrentPos = null;
        let isJoystickActive = false;
        const joystickRadius = 90;
        const maxSpeed = 0.3;
        let joystickCenter = { x: 0, y: 0 };
        let isGetClickedPointMode = false;
        let isConnectingNode = false;
        let isDeletingConnect = false;
        let taskPointData = null;

        // 界面辅助函数
        function resizeCanvas() {
            const mapArea = document.getElementById('map-area');
            canvas.width = mapArea.clientWidth;
            canvas.height = mapArea.clientHeight;
            isViewDirty = true;
        }

        function initLogPanelPosition() {
            const controlsHeight = mapControls.offsetHeight;
            const controlsTop = parseInt(window.getComputedStyle(mapControls).top);
            rosLogPanel.style.top = `${controlsTop + controlsHeight + 10}px`;
            rosLogPanel.style.width = `${mapControls.offsetWidth}px`;
        }

        document.querySelectorAll('.collapse-header').forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.getAttribute('data-target');
                const targetBody = document.getElementById(targetId);
                header.classList.toggle('active');
                targetBody.classList.toggle('show');
            });
        });

        function showPanel() {
            sidePanel.classList.add('show');
            overlay.classList.add('show');
        }

        function hidePanel() {
            sidePanel.classList.remove('show');
            overlay.classList.remove('show');
        }

        function updateRobotState(state) {
            const battery = Math.max(0, Math.min(100, state.battery || 0));
            const isCharging = state.charge === '充电中' || state.charge === '已充满';

            batteryFill.style.width = `${battery}%`;
            batteryPercent.textContent = `${battery}%`;

            if (isCharging) {
                batteryFill.classList.add('charging');
                chargeText.classList.add('show');
            } else {
                batteryFill.classList.remove('charging');
                chargeText.classList.remove('show');
                batteryFill.style.backgroundColor = battery < 20 ? '#ff4444' : '#22c322';
            }
        }

        function addRosLog(level, message) {
            const logItem = document.createElement('li');
            logItem.className = level;
            const now = new Date();
            const timeStr = now.toLocaleTimeString('zh-CN', { hour12: false });
            logItem.textContent = `[${timeStr}] ${message}`;

            rosLogList.insertBefore(logItem, rosLogList.firstChild);

            if (rosLogList.children.length > MAX_LOG_ITEMS) {
                rosLogList.removeChild(rosLogList.lastChild);
            }

            rosLogList.scrollTop = 0;
        }



        // 画布绘制
        function initOffscreenCanvas() {
            if (!mapData || offscreenCanvas) return;
            offscreenCanvas = document.createElement('canvas');
            offscreenCtx = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = mapData.info.width;
            offscreenCanvas.height = mapData.info.height;
        }

        function drawOffscreenMap() {
            if (!mapData || !offscreenCtx) return;
            const info = mapData.info;
            const data = mapData.data;
            for (let y = 0; y < info.height; y++) {
                for (let x = 0; x < info.width; x++) {
                    const idx = y * info.width + x;
                    const value = data[idx];
                    if (value === 0) offscreenCtx.fillStyle = '#f0f0f0';
                    else if (value === 100) offscreenCtx.fillStyle = '#333333';
                    else if (value === -1) offscreenCtx.fillStyle = '#cccccc';
                    else continue;
                    offscreenCtx.fillRect(x, y, 1, 1);
                }
            }
        }

        function worldToCanvas(x, y) {
            if (!mapData) return { x: 0, y: 0 };
            const info = mapData.info;
            const resolution = info.resolution;

            const px = (x - info.origin.position.x) / resolution;
            const py = (y - info.origin.position.y) / resolution;
            const translatedX = px + viewState.translateX;
            const translatedY = py + viewState.translateY;
            const cos = Math.cos(viewState.rotation);
            const sin = Math.sin(viewState.rotation);
            const rotatedX = translatedX * cos - translatedY * sin;
            const rotatedY = translatedX * sin + translatedY * cos;
            const scaledX = rotatedX * viewState.scale;
            const scaledY = rotatedY * viewState.scale;
            const screenX = scaledX + canvas.width / 2;
            const screenY = -scaledY + canvas.height / 2;

            return { x: screenX, y: screenY };
        }

        function canvasToWorld(screenX, screenY) {
            if (!mapData) return null;
            const info = mapData.info;
            const resolution = info.resolution;

            const centeredX = screenX - canvas.width / 2;
            const centeredY = -(screenY - canvas.height / 2);
            const scaledX = centeredX / viewState.scale;
            const scaledY = centeredY / viewState.scale;
            const cos = Math.cos(-viewState.rotation);
            const sin = Math.sin(-viewState.rotation);
            const rotatedX = scaledX * cos - scaledY * sin;
            const rotatedY = scaledX * sin + scaledY * cos;
            const translatedX = rotatedX - viewState.translateX;
            const translatedY = rotatedY - viewState.translateY;

            const worldX = info.origin.position.x + translatedX * resolution;
            const worldY = info.origin.position.y + translatedY * resolution;

            return { x: worldX, y: worldY, z: 0.0 };
        }

        function getColor(markerColor) {
            const r = markerColor.r / 255.0;
            const g = markerColor.g / 255.0;
            const b = markerColor.b / 255.0;
            const a = markerColor.a;
            return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
        }

        function drawSphere(marker) {
            if (!mapData || !showMarkersCheckbox.checked) return;
            ctx.save();

            const info = mapData.info;
            const resolution = info.resolution;
            const worldRadius = marker.scale.x;
            const pixelRadius = (worldRadius / resolution) * viewState.scale;
            const screenPos = worldToCanvas(marker.pose.position.x, marker.pose.position.y);

            ctx.fillStyle = getColor(marker.color);
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, pixelRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = `rgba(0,0,0,${marker.color.a * 0.5})`;
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        function drawText(marker) {
            if (!mapData || !showMarkersCheckbox.checked) return;
            ctx.save();
            const screenPos = worldToCanvas(marker.pose.position.x, marker.pose.position.y);
            const info = mapData.info;
            const fontSize = (marker.scale.z / info.resolution) * viewState.scale * 1.5;

            ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
            ctx.font = `${Math.max(8, fontSize)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(marker.text, screenPos.x, screenPos.y);
            ctx.restore();
        }

        function drawLineStrip(marker) {
            if (!mapData || !showMarkersCheckbox.checked || !marker || !marker.points || marker.points.length < 2) return;
            const validPoints = marker.points.filter(point =>
                point.x !== undefined && point.y !== undefined && !isNaN(point.x) && !isNaN(point.y)
            );
            if (validPoints.length < 2) return;

            ctx.save();

            if (marker.color) ctx.strokeStyle = getColor(marker.color);
            else ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';

            const info = mapData.info;
            const baseLineWidth = marker.scale?.x || 0.1;
            ctx.lineWidth = (baseLineWidth / info.resolution) * viewState.scale * 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 0; i < validPoints.length; i += 2) {
                if (i + 1 >= validPoints.length) break;

                const pointA = validPoints[i];
                const pointB = validPoints[i + 1];
                const canvasA = worldToCanvas(pointA.x, pointA.y);
                const canvasB = worldToCanvas(pointB.x, pointB.y);

                ctx.beginPath();
                ctx.moveTo(canvasA.x, canvasA.y);
                ctx.lineTo(canvasB.x, canvasB.y);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawPointCloud() {
            if (!mapData || !pointCloudData || !showPointcloudCheckbox.checked) return;

            ctx.save();
            const points = pointCloudData.points;
            const info = mapData.info;
            const resolution = info.resolution;
            const pointSize = (0.02 / resolution) * viewState.scale;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const screenPos = worldToCanvas(point.x, point.y);
                ctx.beginPath();
                ctx.rect(
                    screenPos.x - pointSize / 2,
                    screenPos.y - pointSize / 2,
                    pointSize,
                    pointSize
                );
                ctx.fill();
            }

            ctx.restore();
        }

        function drawRobot() {
            if (!robotPose || !mapData || !showRobotCheckbox.checked) return;
            const robotScreenPos = worldToCanvas(robotPose.pose.position.x, robotPose.pose.position.y);
            const o = robotPose.pose.orientation;
            const yaw = -Math.atan2(2 * (o.w * o.z + o.x * o.y), 1 - 2 * (o.y * o.y + o.z * o.z));

            ctx.save();
            ctx.translate(robotScreenPos.x, robotScreenPos.y);
            ctx.rotate(yaw - viewState.rotation);

            ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.moveTo(18, 0);
            ctx.lineTo(-9, 9);
            ctx.lineTo(-9, -9);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawInitPose() {
            if (isSettingInitPose && initPoseStartPos && initPoseCurrentPos && mapData) {
                const startWorldPos = canvasToWorld(initPoseStartPos.x, initPoseStartPos.y);
                if (startWorldPos) {
                    const startScreenPos = worldToCanvas(startWorldPos.x, startWorldPos.y);
                    const dx = initPoseCurrentPos.x - startScreenPos.x;
                    const dy = initPoseCurrentPos.y - startScreenPos.y;
                    const angle = Math.atan2(dy, dx) - viewState.rotation;

                    ctx.save();
                    ctx.translate(startScreenPos.x, startScreenPos.y);
                    ctx.rotate(angle + viewState.rotation);

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = 'rgba(0, 200, 0, 1)';
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(-10, -10);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        function drawMarker(marker) {
            if (!marker) return;
            if (marker.type === 2 || marker.type === 9) drawText(marker);
            if (marker.type === 5) drawLineStrip(marker);
            if (marker.type === 2) drawSphere(marker);
        }



        function draw() {
            if (!isViewDirty && !isSettingInitPose) return;
            if (!mapData || !offscreenCanvas) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const info = mapData.info;

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(1, -1);
            ctx.scale(viewState.scale, viewState.scale);
            ctx.rotate(viewState.rotation);
            ctx.translate(viewState.translateX, viewState.translateY);
            ctx.drawImage(offscreenCanvas, 0, 0);
            ctx.restore();

            drawPointCloud();

            if (markerArrayData) markerArrayData.forEach(marker => drawMarker(marker));

            drawRobot();
            drawInitPose();
            drawMarker(taskPointData);

            isViewDirty = false;
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        function resetView() {
            if (!mapData) return;
            const info = mapData.info;

            viewState.scale = 10.0;
            viewState.rotation = 0.0;

            const mapCenterPixelX = info.width / 2;
            const mapCenterPixelY = info.height / 2;

            viewState.translateX = -mapCenterPixelX;
            viewState.translateY = -mapCenterPixelY;

            isViewDirty = true;
        }

        function toggleInitPoseMode(enable) {
            isSettingInitPose = enable;
            if (isSettingInitPose) {
                initPoseBtn.textContent = "取消位姿";
                statusToast.textContent = "设置初始位姿：单击拖拽确定位置和方向";
                if (isGetClickedPointMode) toggleGetClickedPointMode(false);
            } else {
                initPoseBtn.textContent = "初始位姿";
                setTimeout(() => {
                    if (rosHandler.connectStatus) {
                        const pointCount = pointCloudData ? pointCloudData.points.length : 0;
                        statusToast.textContent = `已连接 ROS | 点云点数：${pointCount}`;
                    } else {
                        statusToast.textContent = '连接状态：未连接';
                    }
                }, 2000);
            }
            initPoseStartPos = null;
            initPoseCurrentPos = null;
            isViewDirty = true;
        }

        function zoomMap(delta) {
            viewState.scale *= (1 + delta);
            viewState.scale = Math.max(0.5, Math.min(50, viewState.scale));
            isViewDirty = true;
        }

        function rotateMap(angle) {
            viewState.rotation += angle;
            isViewDirty = true;
        }

        // 功能模块逻辑
        function toggleGetClickedPointMode(enable) {
            isGetClickedPointMode = enable;
            const mapArea = document.getElementById('map-area');

            if (isGetClickedPointMode) {
                getClickedPointBtn.classList.add('active');
                mapLockToast.classList.add('show');
                mapArea.style.cursor = 'crosshair';
                statusToast.textContent = '已开启获取地图点，单击地图发布坐标';
                if (isSettingInitPose) toggleInitPoseMode(false);
            } else {
                getClickedPointBtn.classList.remove('active');
                mapLockToast.classList.remove('show');
                mapArea.style.cursor = 'default';
                if (rosHandler.connectStatus) {
                    const pointCount = pointCloudData ? pointCloudData.points.length : 0;
                    statusToast.textContent = `已连接 ROS | 点云点数：${pointCount}`;
                } else {
                    statusToast.textContent = '连接状态：未连接';
                }
            }
        }

        function handleMapClick(e) {
            if (!isGetClickedPointMode || !mapData) return;

            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            const worldPos = canvasToWorld(screenX, screenY);
            if (!worldPos) return;

            const now = new Date();
            const pointMsg = new ROSLIB.Message({
                header: {
                    seq: 0,
                    stamp: {
                        secs: Math.floor(now.getTime() / 1000),
                        nsecs: (now.getTime() % 1000) * 1000000
                    },
                    frame_id: "map"
                },
                point: {
                    x: worldPos.x,
                    y: worldPos.y,
                    z: worldPos.z
                }
            });
            rosHandler.publish('/clicked_point', pointMsg);

            statusToast.textContent = `已发布坐标: (${worldPos.x.toFixed(3)}, ${worldPos.y.toFixed(3)}, ${worldPos.z.toFixed(3)})`;
        }

        function updateNodeSelectList() {
            if (!markerArrayData) return;

            nodeSelect.innerHTML = '<option value="">请选择节点</option>';
            nodeMap = new Map();

            const textMarkers = markerArrayData.filter(marker => marker.type === 9);
            const sphereMarkers = markerArrayData.filter(marker => marker.type === 2);

            textMarkers.forEach((textMarker, index) => {
                const nodeName = textMarker.text || `节点${index + 1}`;
                if (sphereMarkers[index]) {
                    const nodeX = sphereMarkers[index].pose.position.x;
                    const nodeY = sphereMarkers[index].pose.position.y;
                    nodeMap.set(nodeName, { x: nodeX, y: nodeY });
                    const option = document.createElement('option');
                    option.value = nodeName;
                    option.textContent = nodeName;
                    nodeSelect.appendChild(option);
                }
            });

            if (nodeMap.size > 0 && rosHandler.connectStatus) {
                statusToast.textContent = `已加载 ${nodeMap.size} 个导航节点`;
            }
        }

        function initJoystickCenter() {
            const wrapper = document.querySelector('.joystick-wrapper');
            const rect = wrapper.getBoundingClientRect();
            joystickCenter.x = rect.left + rect.width / 2;
            joystickCenter.y = rect.top + rect.height / 2;
        }

        function calculateJoystickMove(clientX, clientY) {
            if (!isJoystickActive) return;

            let dx = clientX - joystickCenter.x;
            let dy = clientY - joystickCenter.y;

            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > joystickRadius) {
                const ratio = joystickRadius / distance;
                dx *= ratio;
                dy *= ratio;
            }

            joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

            const linearX = -dy / joystickRadius * maxSpeed;
            const angularZ = -dx / joystickRadius * 1.0;

            rosHandler.publish('/ui_cmd_vel', new ROSLIB.Message({
                linear: { x: linearX, y: 0, z: 0 },
                angular: { x: 0, y: 0, z: angularZ }
            }));
        }

        function resetJoystick() {
            isJoystickActive = false;
            joystickKnob.style.transform = 'translate(0, 0)';

            rosHandler.publish('/ui_cmd_vel', new ROSLIB.Message({
                linear: { x: 0, y: 0, z: 0 },
                angular: { x: 0, y: 0, z: 0 }
            }));
        }

        function toggleReflectionDebug() {
            isReflectionDebugActive = !isReflectionDebugActive;
            if (isReflectionDebugActive) {
                btnReflectionDebug.textContent = '关闭反光贴调试';
                btnReflectionDebug.classList.add('reflection-active');
                statusToast.textContent = '已开启反光贴调试模式';
            } else {
                btnReflectionDebug.textContent = '开启反光贴调试';
                btnReflectionDebug.classList.remove('reflection-active');
                statusToast.textContent = '已关闭反光贴调试模式';
            }
            publishRemoteCmd(20);
        }

        // 事件绑定
        window.addEventListener('resize', () => {
            resizeCanvas();
            initLogPanelPosition();
        });

        btnShowPanel.addEventListener('click', showPanel);
        btnClosePanel.addEventListener('click', hidePanel);
        overlay.addEventListener('click', hidePanel);

        btnShowRemote.addEventListener('click', () => {
            showPanel();
            const joystickHeader = document.querySelector('[data-target="joystick-body"]');
            const joystickBody = document.getElementById('joystick-body');
            joystickHeader.classList.add('active');
            joystickBody.classList.add('show');
            joystickHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });

        resetViewBtn.addEventListener('click', resetView);
        initPoseBtn.addEventListener('click', () => toggleInitPoseMode(!isSettingInitPose));
        getClickedPointBtn.addEventListener('click', () => toggleGetClickedPointMode(!isGetClickedPointMode));
        zoomInBtn.addEventListener('click', () => zoomMap(0.2));
        zoomOutBtn.addEventListener('click', () => zoomMap(-0.2));
        rotateLeftBtn.addEventListener('click', () => rotateMap(-Math.PI / 18));
        rotateRightBtn.addEventListener('click', () => rotateMap(Math.PI / 18));
        showPointcloudCheckbox.addEventListener('change', () => isViewDirty = true);
        showMarkersCheckbox.addEventListener('change', () => isViewDirty = true);
        showRobotCheckbox.addEventListener('change', () => isViewDirty = true);
        canvas.addEventListener('click', handleMapClick);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (isGetClickedPointMode || isSettingInitPose) return;

            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            zoomMap(zoomDelta);
            statusToast.textContent = `地图缩放：${(viewState.scale).toFixed(1)}倍`;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (isGetClickedPointMode) return;

            if (isSettingInitPose) {
                const rect = canvas.getBoundingClientRect();
                initPoseStartPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                initPoseCurrentPos = { ...initPoseStartPos };
                isViewDirty = true;
                return;
            }
            isDragging = true;
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (isGetClickedPointMode) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isSettingInitPose && initPoseStartPos) {
                initPoseCurrentPos = { x, y };
                isViewDirty = true;
                return;
            }
            if (isDragging) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;

                const pixelDeltaX = dx / viewState.scale;
                const pixelDeltaY = -dy / viewState.scale;

                const cos = Math.cos(-viewState.rotation);
                const sin = Math.sin(-viewState.rotation);
                const rotatedDx = pixelDeltaX * cos - pixelDeltaY * sin;
                const rotatedDy = pixelDeltaX * sin + pixelDeltaY * cos;

                viewState.translateX += rotatedDx;
                viewState.translateY += rotatedDy;

                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                isViewDirty = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (isGetClickedPointMode) return;

            if (isSettingInitPose) {
                if (initPoseStartPos && initPoseCurrentPos && mapData) {
                    const worldPos = canvasToWorld(initPoseStartPos.x, initPoseStartPos.y);
                    if (worldPos) {
                        const dx = initPoseCurrentPos.x - initPoseStartPos.x;
                        const dy = initPoseCurrentPos.y - initPoseStartPos.y;
                        let yaw = Math.atan2(-dy, dx) - viewState.rotation;

                        const now = new Date();
                        const poseMsg = new ROSLIB.Message({
                            header: {
                                seq: 0,
                                stamp: { secs: now.getTime() / 1000 | 0, nsecs: (now.getTime() % 1000) * 1000000 },
                                frame_id: "map"
                            },
                            pose: {
                                pose: {
                                    position: { x: worldPos.x, y: worldPos.y, z: 0.0 },
                                    orientation: { x: 0.0, y: 0.0, z: Math.sin(yaw / 2), w: Math.cos(yaw / 2) }
                                }
                            }
                        });

                        rosHandler.publish('/initialpose', poseMsg);
                        statusToast.textContent = `已发布初始位姿: (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`;
                    }
                }
                toggleInitPoseMode(false);
            }
            isDragging = false;
        });

        // 摇杆事件
        joystickKnob.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isJoystickActive = true;
            initJoystickCenter();
            calculateJoystickMove(e.clientX, e.clientY);
        });

        joystickKnob.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isJoystickActive = true;
            initJoystickCenter();
            const touch = e.touches[0];
            calculateJoystickMove(touch.clientX, touch.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            if (isJoystickActive) {
                e.preventDefault();
                calculateJoystickMove(e.clientX, e.clientY);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (isJoystickActive) {
                e.preventDefault();
                const touch = e.touches[0];
                calculateJoystickMove(touch.clientX, touch.clientY);
            }
        });

        ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(event => {
            document.addEventListener(event, () => isJoystickActive && resetJoystick());
        });

        // 导航功能
        btnSetGoalFromNode.addEventListener('click', () => {
            const selectedNodeName = nodeSelect.value;
            if (!selectedNodeName || !nodeMap.has(selectedNodeName)) {
                statusToast.textContent = '请先选择有效的导航节点';
                return;
            }

            const nodePos = nodeMap.get(selectedNodeName);
            const goalX = nodePos.x;
            const goalY = nodePos.y;
            statusToast.textContent = `已设置目标点：${selectedNodeName} (${goalX.toFixed(3)}, ${goalY.toFixed(3)})`;

            publishRemoteCmd(7, selectedNodeName);
        });

        btnStartNav.addEventListener('click', () => {
            const selectedNodeName = nodeSelect.value;
            let goalX = 0.0, goalY = 0.0;

            if (selectedNodeName && nodeMap.has(selectedNodeName)) {
                const nodePos = nodeMap.get(selectedNodeName);
                goalX = nodePos.x;
                goalY = nodePos.y;
                statusToast.textContent = '选择节点: ' + selectedNodeName;
            } else {
                statusToast.textContent = '未选择节点';
                return;
            }

            const publishSuccess = publishRemoteCmd(8, selectedNodeName || '');
            if (publishSuccess) {
                statusToast.textContent = `导航目标：(${goalX.toFixed(3)}, ${goalY.toFixed(3)})，已发布/remote_cmd`;
            }

            resetJoystick();
            if (isGetClickedPointMode) toggleGetClickedPointMode(false);
        });

        btnStopNav.addEventListener('click', () => {
            resetJoystick();
            const publishSuccess = publishRemoteCmd(9);
            if (publishSuccess) {
                statusToast.textContent = '已停止导航';
            }
        });

        // 系统设置
        btnConnectNode.addEventListener('click', () => {
            isConnectingNode = !isConnectingNode;
            if (isConnectingNode) {
                btnConnectNode.classList.add('active');
                btnConnectNode.textContent = '取消连接';
                statusToast.textContent = '请依次点击两个节点建立连接';
                isDeletingConnect = false;
                btnDelConnect.classList.remove('active');
                btnDelConnect.textContent = '删除连接';
            } else {
                btnConnectNode.classList.remove('active');
                btnConnectNode.textContent = '连接节点';
                statusToast.textContent = '已取消节点连接操作';
            }
            publishRemoteCmd(11);
        });

        btnDelConnect.addEventListener('click', () => {
            isDeletingConnect = !isDeletingConnect;
            if (isDeletingConnect) {
                btnDelConnect.classList.add('active');
                btnDelConnect.textContent = '取消删除';
                statusToast.textContent = '请点击要删除的节点连接';
                isConnectingNode = false;
                btnConnectNode.classList.remove('active');
                btnConnectNode.textContent = '连接节点';
            } else {
                btnDelConnect.classList.remove('active');
                btnDelConnect.textContent = '删除连接';
                statusToast.textContent = '已取消连接删除操作';
            }
            publishRemoteCmd(12);
        });

        btnAddNode.addEventListener('click', () => {
            const nodeName = nodeNameInput.value.trim();
            if (!nodeName) {
                statusToast.textContent = '请输入有效的节点名称';
                return;
            }
            const publishSuccess = publishRemoteCmd(10, nodeName);
            if (publishSuccess) {
                statusToast.textContent = `已提交插入节点：${nodeName}`;
                nodeNameInput.value = '';
            }
        });

        btnDelNode.addEventListener('click', () => {
            const selectedNode = nodeNameInput.value.trim();
            if (!selectedNode) {
                statusToast.textContent = '请输入要删除的节点';
                return;
            }
            const publishSuccess = publishRemoteCmd(19, selectedNode);
            if (publishSuccess) {
                statusToast.textContent = `已提交删除节点：${selectedNode}`;
                nodeSelect.value = '';
            }
        });

        btnSavePath.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(14);
            if (publishSuccess) {
                statusToast.textContent = '正在保存路径数据...';
            }
        });

        btnModifyDir.addEventListener('click', () => {
            const selectedNodeName = nodeNameInput.value.trim();
            if (!selectedNodeName || !nodeMap.has(selectedNodeName)) {
                statusToast.textContent = '请先输入有效的导航节点';
                return;
            }
            const publishSuccess = publishRemoteCmd(15, selectedNodeName);
            if (publishSuccess) {
                statusToast.textContent = '修改目标节点方向指令已发送';
            }
        });

        btnSetCharge.addEventListener('click', () => {
            const selectedNodeName = nodeNameInput.value.trim();
            if (!selectedNodeName || !nodeMap.has(selectedNodeName)) {
                statusToast.textContent = '请先输入要设置为充电点的节点';
                return;
            }
            const publishSuccess = publishRemoteCmd(16, selectedNodeName);
            if (publishSuccess) {
                statusToast.textContent = `已将 ${selectedNodeName} 设置为充电点`;
            }
        });

        btnOnekeyCharge.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(17);
            if (publishSuccess) {
                statusToast.textContent = '已发送一键充电指令';
                updateRobotState({
                    battery: parseInt(batteryPercent.textContent),
                    charge: '充电中'
                });
            }
        });

        btnEndCharge.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(18);
            if (publishSuccess) {
                statusToast.textContent = '已发送结束充电指令';
                updateRobotState({
                    battery: parseInt(batteryPercent.textContent),
                    charge: '未充电'
                });
            }
        });

        // 调试控制
        btnLeftFeed.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(2);
            if (publishSuccess) statusToast.textContent = '已发送左侧上料指令（seq=2）';
        });

        btnRightFeed.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(3);
            if (publishSuccess) statusToast.textContent = '已发送右侧上料指令（seq=3）';
        });

        btnLeftUnload.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(4);
            if (publishSuccess) statusToast.textContent = '已发送左侧下料指令（seq=4）';
        });

        btnRightUnload.addEventListener('click', () => {
            const publishSuccess = publishRemoteCmd(5);
            if (publishSuccess) statusToast.textContent = '已发送右侧下料指令（seq=5）';
        });

        btnReflectionDebug.addEventListener('click', toggleReflectionDebug);

        // 初始化
        registerAllSubTopics();
        registerAllPubTopics();
        resizeCanvas();
        initLogPanelPosition();
        initJoystickCenter();
        animate();
        rosHandler.connect();

        document.querySelector('.panel-content').addEventListener('scroll', initJoystickCenter);

        window.addEventListener('beforeunload', () => {
            if (rosHandler.reconnectTimer) clearTimeout(rosHandler.reconnectTimer);
        });
    </script>
    <script type="text/javascript" src="js/sensor_control.js"></script>
</body>

</html>